let fieldSize: number; // = 100; //–≤—Å–µ–≥–æ –∫–ª–µ—Ç–æ–∫
let minesCount: number; //–≤—Å–µ–≥–æ –º–∏–Ω
let fieldWidth: number; //—à–∏—Ä–∏–Ω–∞ –ø–æ–ª—è
let arrField: number[]; //–∫–ª–µ—Ç–∫–∏ —Å –º–∏–Ω–∞–º–∏
let arrChecked: boolean[]; //–∫–ª–µ—Ç–∫–∏ –∫—É–¥–∞ —É–∂–µ —Ç—ã–∫–∞–ª–∏
let minesLeft: number;
const buttonsContainer = document.querySelector('.buttons');
const playerNameInput = document.getElementById('playerName');
const timeElapsedInput = document.getElementById('timeElapsed');
const minesLeftInput: HTMLInputElement = document.getElementById('minesLeft') as HTMLInputElement;


//// MultyWindows APP
// let uuid: string;
// let difficulty: string;
let gameStatus: number = 5; //5 new game; 0 game starting; 1 over; 2 win

///////////
function showElement(elementId: string) {
    document.getElementById(elementId).style.display = 'block';
}

function hideElement(elementId: string) {
    document.getElementById(elementId).style.display = 'none';
}

window.onload = () => {
    startNewGame()
}

function startNewGame(){
    const fieldSizeSlider = document.getElementById('fieldSize') as HTMLInputElement;
    const fieldSizeValueDisplay = document.getElementById('fieldSizeValue') as HTMLElement;

    fieldSizeSlider.oninput = () => {
        fieldSizeValueDisplay.textContent = fieldSizeSlider.value;
    };

    const gameSettingsForm = document.getElementById('gameSettings') as HTMLFormElement;
    gameSettingsForm.onsubmit = (event) => {
        event.preventDefault();

        let difficulty = (document.getElementById('difficulty') as HTMLSelectElement).value;
        fieldWidth = parseInt(fieldSizeSlider.value)
        const createGame = async (size: number, difficulty: string) => {
            try {
                const response = await fetch(`http://localhost:8080/newgame?difficulty=${difficulty}&size=${size}`);
                if (!response.ok) {
                    throw new Error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ —Å–µ—Ä–≤–µ—Ä—É');
                }
                const data = await response.json();
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                startGame(parseInt(data.size), parseInt(data.mines), String(data.guid));
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–≥—Ä—ã:', error);
            }
        };
        createGame(fieldWidth, difficulty)
    };

    // –î—Ä—É–≥–∞—è –ª–æ–≥–∏–∫–∞ –∏–≥—Ä—ã
};

function startGame(fieldS: number, minesC: number, uuid: string): void {
    console.log(`–ò–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞ —Å —Ä–∞–∑–º–µ—Ä–æ–º –ø–æ–ª—è ${fieldS} –∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é ${minesCount}`);
    // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä—ã
    fieldSize = fieldS;
    arrField = new Array(fieldSize).fill(0);
    arrChecked = new Array(fieldSize).fill(false);
    minesCount = minesC;
    minesLeft = minesC;
    minesLeftInput.value = minesLeft.toString();

    //—Å–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏
    buttonsContainer?.setAttribute('style', `grid-template-columns: repeat(${fieldWidth}, 1fr);`);
    arrField.forEach((value, index) => {
        // if (value !== 9 ){
        //     arrField[index] = checkMinesCount(index);
        // }
        const button = document.createElement('button');
        button?.setAttribute('index', index.toString());
        buttonsContainer?.appendChild(button);

        button.addEventListener('click', async function() {
            arrChecked[index] = true; //–ª–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
            const currentIndex = Number(this.getAttribute('index'));
            const currentMines = await getMines(currentIndex, uuid);
            if (this.textContent !== '‚õ≥Ô∏è'){ //–ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Ñ–ª–∞–∂–æ–∫
                if (currentMines === 9) {
                    const allMines: number[] = await getAllMines(uuid);
                    console.log(allMines);
                    for (let indBomb of allMines) {
                        const cell = document.querySelector(`button[index="${indBomb}"]`) as HTMLButtonElement;
                        cell.textContent = 'üí£';
                        cell?.setAttribute('data-value', 'üí£')
                    }
                    setTimeout(() => {
                        alert("–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏!");
                        location.reload();
                    }, 400);
                } else {  // –≤—ã–±–∏—Ä–∞–µ–º —Å–æ—Å–µ–¥–µ–π
                    //let mines: number = checkMinesCount(currentIndex);
                    if (currentMines !== 0) {
                        this.textContent = currentMines.toString()
                        //arrField[currentIndex] = mines;
                    } else {
                        this.textContent = '';
                        checkEmptyCell(currentIndex, uuid);
                        //this.setAttribute('checked', '0');
                    }
                    this.setAttribute('checked', '1');
                }
            }
            win();
        });
        button.addEventListener('contextmenu', function(event) {
            event.preventDefault(); //–ø—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
            if (this.textContent === '‚õ≥Ô∏è') {
                if (this.getAttribute('checked') === '1' && arrField[index] > 0) {
                    this.textContent = arrField[index].toString();
                } else {
                    this.textContent = '';
                }
                minesLeft++;
            } else if (minesLeft > 0){
                this.textContent = '‚õ≥Ô∏è';
                minesLeft--;
            }
            minesLeftInput.value = minesLeft.toString();
            win();
        });
    });
    //
    hideElement("startWindow")
    showElement("gameField")

}

async function getMines(index: number, uuid: string): Promise<number> {
    let mines: number;
    try {
        const response = await fetch(`http://localhost:8080/turn?guid=${uuid}&field=${index}`);
        if (!response.ok) {
            throw new Error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ —Å–µ—Ä–≤–µ—Ä—É');
        }
        const data = await response.json();
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        mines = parseInt(data.mines)
        //console.log("Status game", data.gamestatus)
        //startGame(parseInt(data.size), parseInt(data.mines), String(data.guid));
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–≥—Ä—ã:', error);
    }
    return new Promise(resolve => {
        setTimeout(() => resolve(mines), 10);
    });
}

async function getAllMines(uuid: string): Promise<number[]> {
    let mines: number[];
    try {
        const response = await fetch(`http://localhost:8080/gameover?guid=${uuid}`);
        if (!response.ok) {
            throw new Error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ —Å–µ—Ä–≤–µ—Ä—É');
        }
        const data = await response.json();
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        mines = data.mines
        //startGame(parseInt(data.size), parseInt(data.mines), String(data.guid));
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–≥—Ä—ã:', error);
    }
    return new Promise(resolve => {
        setTimeout(() => resolve(mines), 10);
    });
}
///////////

//win?
function win(): void {
    console.log(fieldSize)
    console.log(minesCount + arrChecked.filter(value => value === true).length)
    if (fieldSize === minesCount + arrChecked.filter(value => value === true).length) {
        setTimeout(() => {
            alert("You win!");
            location.reload();
        }, 400);
    }
}

//—Å—á–∏—Ç–∞–µ–º –ø—É—Å—Ç—ã–µ –ø–æ–ª—è
async function checkEmptyCell(index: number, uuid: string) {
    let neighborI: number[] = [];
    switch (true){
        case (index === 0): //–ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
            neighborI = [1, fieldWidth];
            break;
        case (index === fieldWidth-1): //–ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
            neighborI = [-1, fieldWidth];
            break;
        case (index < fieldWidth): //–≤–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞
            neighborI = [-1, 1, fieldWidth];
            break;
        case (index === fieldSize-fieldWidth): //–ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
            neighborI = [1, -fieldWidth];
            break;
        case (index === fieldSize-1): //–ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
            neighborI = [-1, -fieldWidth];
            break;
        case (index > fieldSize - fieldWidth): //–Ω–∏–∂–Ω—è—è —Å—Ç—Ä–æ–∫–∞
            neighborI = [-1, 1, -fieldWidth];
            break;
        case ((index) % fieldWidth === 0): //–ª–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü
            neighborI = [-fieldWidth, 1, fieldWidth]
            break;
        case ((index + 1) % fieldWidth === 0): //–ø—Ä–∞–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü
            neighborI = [-fieldWidth, -1, fieldWidth];
            break;
        default: //–æ–±—ã—á–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ 4 —Å–æ—Å–µ–¥–∞
            neighborI = [-fieldWidth, -1, 1, fieldWidth];
            //console.log(currentIndex);
    }
    //console.log(`Checkemptycell:`, index)
    for (const element of neighborI) {
        const cellIndex = index + element;
        const cell = document.querySelector(`button[index="${cellIndex}"]`) as HTMLButtonElement;
        if (!cell || arrChecked[cellIndex]) continue; // –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–∞ –∏–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏

        const mines: number = await getMines(cellIndex, uuid);
        //console.log(`Checkemptycell mines:`, mines);

        if (mines === 0 /*&& checkMinesCount(cellIndex) === 0*/) {
            arrChecked[cellIndex] = true;
            cell.setAttribute('checked', '1');
            checkEmptyCell(cellIndex, uuid); //await?
        } else {
            arrChecked[cellIndex] = true;
            cell.textContent = mines.toString();
            cell.setAttribute('checked', '1');
        }
    };
}
